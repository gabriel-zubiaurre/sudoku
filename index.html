<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Sudoku — Dificultades, Timer, Scores y Game ID</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --cell: 3rem;
      --border: 1px solid #333;
      --border-strong: 3px solid #000;
      --light-bg:#ffffff; --light-fg:#111111;
      --dark-bg:#111111;  --dark-fg:#f5f5f5;
      --accent:#0b5ed7;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    body{ margin:1.5rem; background:#fafafa; color:#111; }
    h1{ font-size:1.1rem; margin:0 0 1rem; }
    .row{ display:flex; flex-wrap:wrap; gap:.75rem; align-items:center; margin-bottom:.75rem; }
    select, input[type="text"]{
      padding:.45rem .6rem; border:1px solid #333; background:#fff; min-width:10rem;
    }
    button{
      padding:.5rem .9rem; border:1px solid #333; background:#fff; cursor:pointer;
    }
    button.primary{ background:var(--accent); color:#fff; border-color:var(--accent); }
    button:disabled{ opacity:.6; cursor:default; }
    .grid{
      display:grid; grid-template-columns:repeat(9, var(--cell)); grid-auto-rows:var(--cell);
      width:calc(9 * var(--cell)); background:#000; user-select:none;
    }
    .cell{
      position:relative; display:flex; align-items:center; justify-content:center;
      border:var(--border); font-size:1.2rem;
    }
    .cell input{
      width:100%; height:100%; border:none; outline:none;
      text-align:center; font:inherit; background:transparent; color:inherit;
    }
    .cell input:disabled{ font-weight:700; }
    /* Bordes fuertes (bloques 3×3) y perímetro */
    .r-0{ border-top:var(--border-strong) !important; }
    .r-3{ border-top:var(--border-strong) !important; }
    .r-6{ border-top:var(--border-strong) !important; }
    .r-8b{ border-bottom:var(--border-strong) !important; }
    .c-0{ border-left:var(--border-strong) !important; }
    .c-3{ border-left:var(--border-strong) !important; }
    .c-6{ border-left:var(--border-strong) !important; }
    .c-8b{ border-right:var(--border-strong) !important; }

    /* Patrón ajedrez por bloque 3×3 */
    .light{ background:var(--light-bg); color:var(--light-fg); }
    .dark{  background:var(--dark-bg);  color:var(--dark-fg); }

    .panel{ margin-top:1rem; display:grid; grid-template-columns:1fr; gap:.6rem; max-width: calc(9 * var(--cell)); }
    .metric{ display:flex; justify-content:space-between; background:#fff; border:1px solid #ddd; padding:.5rem .75rem; }
    .scores{ background:#fff; border:1px solid #ddd; padding:.75rem; }
    table{ width:100%; border-collapse:collapse; }
    th, td{ padding:.4rem .3rem; border-bottom:1px solid #eee; text-align:left; font-size:.95rem; }
    .muted{ color:#666; font-size:.9rem; }
    .ok{ color:#0a7f27; font-weight:700; }
    .warn{ color:#b34b00; font-weight:700; }
    .gameid{ display:flex; gap:.5rem; }
    .gameid input{ flex:1; }
    .small{ font-size:.9rem; }
    .footer{ margin-top:1rem; color:#444; font-size:.9rem; }
  </style>
</head>
<body>
  <h1>Sudoku — Dificultad, Timer, Scores y Game ID</h1>

  <div class="row">
    <label for="difficulty">Dificultad:</label>
    <select id="difficulty" aria-label="Dificultad">
      <option value="easy">Fácil</option>
      <option value="medium">Medio</option>
      <option value="hard">Difícil</option>
      <option value="expert">Experto</option>
    </select>

    <button id="new" class="primary">Nuevo juego</button>
    <button id="pause">Pausar</button>
    <span id="status" class="muted">Listo</span>
  </div>

  <div class="row gameid">
    <input id="gameId" type="text" readonly aria-label="Game ID actual" title="Game ID actual" />
    <button id="copyId">Copiar ID</button>
    <input id="loadId" type="text" placeholder="Pegar Game ID para cargar…" aria-label="Pegar Game ID" />
    <button id="loadBtn">Cargar</button>
  </div>

  <div id="grid" class="grid" aria-label="Tablero Sudoku"></div>

  <div class="panel">
    <div class="metric">
      <div><strong>Tiempo</strong></div>
      <div id="timer">00:00</div>
    </div>

    <div class="scores">
      <div class="row" style="justify-content:space-between; margin:0">
        <strong>Mejores tiempos por dificultad</strong>
        <button id="clearScores">Borrar scores</button>
      </div>
      <table>
        <thead><tr><th>Dificultad</th><th>Tiempo</th><th>Game ID</th><th>Fecha</th></tr></thead>
        <tbody id="scoresBody"></tbody>
      </table>
      <div class="muted small">Los scores se guardan en este dispositivo (localStorage).</div>
    </div>
  </div>

  <div class="footer">
    Puede compartirse el juego por URL con parámetros <code>?id=AB12CD&diff=hard</code>.
  </div>

<script>
/* =======================
   Utilidades y PRNG seeded
   ======================= */
const BASE=3, SIDE=BASE*BASE;

/* Hash sencillo a entero (xmur3) y PRNG mulberry32 */
function xmur3(str){
  let h=1779033703 ^ str.length;
  for(let i=0;i<str.length;i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function(){
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
function rngFromSeedString(s){
  const seedInt = xmur3(s)();
  return { rng: mulberry32(seedInt), seedInt };
}
function randInt(rng, min, max){ // [min, max)
  return Math.floor(rng()*(max-min))+min;
}
function shuffleSeeded(arr, rng){
  const a=arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(rng()* (i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function seedToCode(seedInt){
  return seedInt.toString(36).toUpperCase();
}
function codeToSeed(code){
  return parseInt(code, 36) >>> 0;
}

/* =======================
   Generación de solución
   ======================= */
function pattern(r,c){ return (BASE * (r % BASE) + Math.floor(r/BASE) + c) % SIDE; }

function generarSolucion(seedStr){
  const { rng, seedInt } = rngFromSeedString(seedStr);
  const rBase=[0,1,2];
  const filas = shuffleSeeded(rBase, rng).flatMap(g => shuffleSeeded(rBase, rng).map(r => g*BASE + r));
  const cols  = shuffleSeeded(rBase, rng).flatMap(g => shuffleSeeded(rBase, rng).map(c => g*BASE + c));
  const nums  = shuffleSeeded([1,2,3,4,5,6,7,8,9], rng);
  const board = Array.from({length:SIDE}, (_,r)=>
    Array.from({length:SIDE}, (_,c)=> nums[pattern(filas[r], cols[c])])
  );
  return { board, seedInt };
}

/* =======================
   Solver y unicidad
   ======================= */
function findEmpty(board){
  for(let r=0;r<SIDE;r++){
    for(let c=0;c<SIDE;c++){
      if(board[r][c]===0) return [r,c];
    }
  }
  return null;
}
function isValid(board, r, c, val){
  for(let i=0;i<SIDE;i++){
    if(board[r][i]===val || board[i][c]===val) return false;
  }
  const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
  for(let i=0;i<3;i++){
    for(let j=0;j<3;j++){
      if(board[br+i][bc+j]===val) return false;
    }
  }
  return true;
}
// Cuenta soluciones hasta dos (1 = única, 2 = múltiple)
function countSolutions(board){
  let count=0;
  function backtrack(){
    if(count>1) return; // poda
    const empty = findEmpty(board);
    if(!empty){ count++; return; }
    const [r,c]=empty;
    for(let v=1; v<=9; v++){
      if(isValid(board, r, c, v)){
        board[r][c]=v;
        backtrack();
        board[r][c]=0;
        if(count>1) return;
      }
    }
  }
  backtrack();
  return count;
}

/* =======================
   Construcción de puzzle
   ======================= */
const DIFFS = {
  easy:   { clues: 40, code:'E' },
  medium: { clues: 34, code:'M' },
  hard:   { clues: 28, code:'H' },
  expert: { clues: 24, code:'X' },
};

function clone(board){ return board.map(row=>row.slice()); }

function buildPuzzle(solution, diffKey, seedStr){
  const { rng } = rngFromSeedString(seedStr + ':' + diffKey);
  const targetClues = DIFFS[diffKey].clues;
  const puzzle = clone(solution).map(row=>row.slice());
  let removed = 0;
  const totalCells = 81;
  const targetRemoved = totalCells - targetClues;

  // Lista de posiciones 0..80, barajada para intentar removals
  const cells = shuffleSeeded([...Array(81).keys()], rng);

  // Remoción simétrica para estética
  function symmetricIndex(idx){ return 80 - idx; }

  for(const idx of cells){
    if(removed >= targetRemoved) break;
    const r = Math.floor(idx/9), c = idx%9;
    const sym = symmetricIndex(idx);
    const r2 = Math.floor(sym/9), c2 = sym%9;

    if(puzzle[r][c]===0 || puzzle[r2][c2]===0) continue;

    const v1 = puzzle[r][c], v2 = puzzle[r2][c2];
    puzzle[r][c]=0; puzzle[r2][c2]=0;

    // Verificar unicidad
    const work = clone(puzzle);
    const solCount = countSolutions(work);
    if(solCount===1){
      removed += (idx===sym ? 1 : 2);
    }else{
      // revertir
      puzzle[r][c]=v1; puzzle[r2][c2]=v2;
    }
  }
  // Si no se alcanzó el objetivo exacto, aceptamos el máximo logrado con unicidad.
  return puzzle;
}

/* =======================
   Render e interacción
   ======================= */
const gridEl = document.getElementById('grid');
const diffSel = document.getElementById('difficulty');
const newBtn  = document.getElementById('new');
const pauseBtn= document.getElementById('pause');
const timerEl = document.getElementById('timer');
const statusEl= document.getElementById('status');
const gameIdEl= document.getElementById('gameId');
const copyIdBtn=document.getElementById('copyId');
const loadIdEl=document.getElementById('loadId');
const loadBtn = document.getElementById('loadBtn');
const scoresBody=document.getElementById('scoresBody');
const clearScoresBtn=document.getElementById('clearScores');

let state = {
  diff:'easy',
  seedCode:'',
  solution:null,
  puzzle:null,
  started:false,
  paused:false,
  startTs:null,
  elapsed:0,
  interval:null,
};

function setStatus(msg, cls='muted'){ statusEl.className=cls; statusEl.textContent=msg; }
function pad(n){ return n<10 ? '0'+n : ''+n; }
function formatTime(sec){ const m=Math.floor(sec/60), s=sec%60; return `${pad(m)}:${pad(s)}`; }

function startTimer(){
  if(state.interval) clearInterval(state.interval);
  state.startTs = Date.now() - state.elapsed*1000;
  state.interval = setInterval(()=>{
    if(!state.paused){
      state.elapsed = Math.floor((Date.now() - state.startTs)/1000);
      timerEl.textContent = formatTime(state.elapsed);
    }
  }, 500);
}

function pauseResume(){
  if(!state.started) return;
  state.paused = !state.paused;
  pauseBtn.textContent = state.paused ? 'Reanudar' : 'Pausar';
  setStatus(state.paused ? 'En pausa' : 'Jugando');
}

function stopTimer(){
  if(state.interval){ clearInterval(state.interval); state.interval=null; }
}

function renderBoard(puzzle, solution){
  gridEl.innerHTML='';
  for(let r=0;r<SIDE;r++){
    for(let c=0;c<SIDE;c++){
      const cell=document.createElement('div');
      cell.className='cell';
      if(r===0) cell.classList.add('r-0');
      if(r===3) cell.classList.add('r-3');
      if(r===6) cell.classList.add('r-6');
      if(r===8) cell.classList.add('r-8b');
      if(c===0) cell.classList.add('c-0');
      if(c===3) cell.classList.add('c-3');
      if(c===6) cell.classList.add('c-6');
      if(c===8) cell.classList.add('c-8b');

      const light = ((Math.floor(r/3)+Math.floor(c/3))%2===0);
      cell.classList.add(light?'light':'dark');

      const input=document.createElement('input');
      input.setAttribute('inputmode','numeric');
      input.setAttribute('maxlength','1');
      input.setAttribute('aria-label', `Fila ${r+1}, Columna ${c+1}`);
      const given = puzzle[r][c]!==0;
      input.value = given ? puzzle[r][c] : '';
      input.disabled = given;

      input.addEventListener('beforeinput', (e)=>{
        // Permite borrar; restringe a [1-9]
        if(e.data===null) return; // borrado
        if(!/[1-9]/.test(e.data)){ e.preventDefault(); }
      });
      input.addEventListener('input', ()=>{
        if(!state.started){
          state.started=true; state.paused=false;
          pauseBtn.textContent='Pausar';
          setStatus('Jugando');
          startTimer();
        }
        const v = input.value.trim();
        if(v.length>1) input.value = v[v.length-1];
        if(v==='') return;

        const num = parseInt(input.value,10);
        // Opcional: marcación correcta/incorrecta mínima
        if(num === solution[r][c]){
          input.classList.remove('warn');
          input.classList.add('ok');
        }else{
          input.classList.remove('ok');
          input.classList.add('warn');
        }
        checkCompletion();
      });

      cell.appendChild(input);
      gridEl.appendChild(cell);
    }
  }
}

function checkCompletion(){
  // Verifica que todas las celdas coincidan con la solución
  const inputs = gridEl.querySelectorAll('input');
  for(let r=0;r<SIDE;r++){
    for(let c=0;c<SIDE;c++){
      const idx=r*9+c;
      const v = inputs[idx].value.trim();
      if(v==='') return false;
      if(parseInt(v,10)!==state.solution[r][c]) return false;
    }
  }
  // Completado
  stopTimer();
  setStatus('Completado', 'ok');
  saveScore(state.diff, state.seedCode, state.elapsed);
  renderScores();
  return true;
}

/* =======================
   Game ID y nueva partida
   ======================= */
function currentGameId(diffKey, seedInt){
  // Formato: <letra-dif>-<base36>
  return `${DIFFS[diffKey].code}-${seedToCode(seedInt)}`;
}
function parseGameId(idStr){
  if(!idStr) return null;
  const m = idStr.trim().toUpperCase().match(/^([EMHX])\-([0-9A-Z]+)$/);
  if(!m) return null;
  const codeToDiff = {E:'easy', M:'medium', H:'hard', X:'expert'};
  const diff = codeToDiff[m[1]];
  const seedInt = codeToSeed(m[2]);
  return { diff, seedInt, seedCode:m[2] };
}
function randomSeedInt(){
  if(window.crypto && crypto.getRandomValues){
    const arr = new Uint32Array(1); crypto.getRandomValues(arr); return arr[0] >>> 0;
  }
  return Math.floor(Math.random()*0xFFFFFFFF) >>> 0;
}

async function newGame(fromId=null){
  setStatus('Generando…');
  stopTimer();
  state.started=false; state.paused=false; state.elapsed=0; timerEl.textContent='00:00';
  let diff = diffSel.value;
  let seedInt;
  if(fromId){
    diff = fromId.diff;
    seedInt = fromId.seedInt;
    diffSel.value = diff;
  }else{
    seedInt = randomSeedInt();
  }
  const seedStr = String(seedInt);
  const { board:solution } = generarSolucion(seedStr);
  const puzzle = buildPuzzle(solution, diff, seedStr);

  state.diff = diff;
  state.solution = solution;
  state.puzzle = puzzle;
  state.seedCode = seedToCode(seedInt);

  renderBoard(puzzle, solution);

  const gid = currentGameId(diff, seedInt);
  gameIdEl.value = gid;
  setStatus('Listo');
  // Actualizar URL con parámetros compartibles
  const url = new URL(window.location.href);
  url.searchParams.set('id', state.seedCode);
  url.searchParams.set('diff', diff);
  history.replaceState(null, '', url.toString());
}

/* =======================
   Scores (localStorage)
   ======================= */
const LS_KEY='sudokuScoresV1';
function loadScores(){
  try{
    const raw=localStorage.getItem(LS_KEY);
    if(!raw) return {};
    return JSON.parse(raw);
  }catch{ return {}; }
}
function saveScores(obj){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(obj)); }catch{}
}
function saveScore(diff, gameCode, seconds){
  const all = loadScores();
  if(!all[diff]) all[diff]=[];
  all[diff].push({ time:seconds, id:gameCode, ts:Date.now() });
  // ordenar asc por tiempo y conservar top 10
  all[diff].sort((a,b)=>a.time-b.time);
  all[diff]=all[diff].slice(0,10);
  saveScores(all);
}
function renderScores(){
  const all = loadScores();
  const rows = [];
  for(const [diffKey, meta] of Object.entries(DIFFS)){
    const list = (all[diffKey]||[]).slice(0,5);
    if(list.length===0){
      rows.push(`<tr><td>${labelDiff(diffKey)}</td><td colspan="3" class="muted">—</td></tr>`);
    }else{
      for(let i=0;i<list.length;i++){
        const s=list[i];
        const date = new Date(s.ts);
        const dstr = date.toISOString().slice(0,10);
        rows.push(`<tr><td>${i===0?labelDiff(diffKey):''}</td><td>${formatTime(s.time)}</td><td>${s.id}</td><td>${dstr}</td></tr>`);
      }
    }
  }
  scoresBody.innerHTML = rows.join('');
}
function labelDiff(k){
  return ({easy:'Fácil', medium:'Medio', hard:'Difícil', expert:'Experto'})[k] || k;
}

/* =======================
   Eventos UI
   ======================= */
newBtn.addEventListener('click', ()=> newGame());
pauseBtn.addEventListener('click', pauseResume);
copyIdBtn.addEventListener('click', async ()=>{
  try{
    await navigator.clipboard.writeText(gameIdEl.value);
    setStatus('Game ID copiado');
    setTimeout(()=>setStatus('Listo'), 1200);
  }catch{}
});
loadBtn.addEventListener('click', ()=>{
  const parsed = parseGameId(loadIdEl.value);
  if(!parsed){ setStatus('Game ID inválido', 'warn'); return; }
  newGame(parsed);
});
clearScoresBtn.addEventListener('click', ()=>{
  localStorage.removeItem(LS_KEY);
  renderScores();
  setStatus('Scores borrados');
});

/* =======================
   Inicialización
   ======================= */
(function initFromURL(){
  const url = new URL(window.location.href);
  const id = (url.searchParams.get('id')||'').toUpperCase();
  const diff = (url.searchParams.get('diff')||'').toLowerCase();
  let parsed = null;
  if(id && ['easy','medium','hard','expert'].includes(diff)){
    // construir Game ID sintético a partir de query
    const letter = ({easy:'E', medium:'M', hard:'H', expert:'X'})[diff];
    parsed = parseGameId(`${letter}-${id}`);
  }
  if(parsed) newGame(parsed); else newGame();
  renderScores();
})();
</script>
</body>
</html>