<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku</title>
  <style>
    :root{
      --accent:#1f6feb;
      --ok:#2da44e;
      --warn:#d1242f;
      --grid:#111;
      --bg1:#fafafa;
      --bg2:#ececec;
      --boxA:#f7faff;
      --boxB:#eef5ff;
    }

    /* Fondo general con patrón de damas */
    body{
      margin:0;
      font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;
      background:
        linear-gradient(45deg, var(--bg2) 25%, transparent 25%) 0 0/40px 40px,
        linear-gradient(-45deg, var(--bg2) 25%, transparent 25%) 0 0/40px 40px,
        linear-gradient(45deg, transparent 75%, var(--bg2) 75%) 0 0/40px 40px,
        linear-gradient(-45deg, transparent 75%, var(--bg2) 75%) 0 0/40px 40px,
        var(--bg1);
      color:#0a0a0a;
    }

    .wrap{
      max-width: 980px;
      margin: 32px auto;
      padding: 24px;
      border-radius: 20px;
      background: rgba(255,255,255,.85);
      box-shadow: 0 10px 30px rgba(0,0,0,.08);
      backdrop-filter: blur(3px);
    }

    h1{ margin:0 0 10px; font-weight:700; font-size: clamp(22px,3vw,30px); }
    .sub{ color:#555; margin-bottom:18px; }

    .toolbar{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-bottom: 18px;
    }
    @media(min-width:700px){
      .toolbar{ grid-template-columns: 1fr auto; align-items:end; }
    }

    .controls{
      display:flex; flex-wrap:wrap; gap:10px;
      align-items:center;
    }
    label{ font-size:14px; color:#333; }
    select, input[type="text"]{
      border:1px solid #d0d7de; border-radius:10px; padding:8px 10px; background:#fff;
      font-size:14px;
    }
    .btn{
      border:1px solid transparent; border-radius:12px; padding:10px 14px; font-weight:600; cursor:pointer;
      background: #f6f8fa;
    }
    .btn.primary{ background: var(--accent); color:#fff; }
    .btn.success{ background: var(--ok); color:#fff; }
    .btn.danger{ background: var(--warn); color:#fff; }
    .btn:disabled{ opacity:.6; cursor:not-allowed; }

    .status{
      display:flex; flex-wrap:wrap; gap:14px; align-items:center; justify-content:flex-end;
      font-size:14px;
    }
    .pill{ padding:6px 10px; border-radius:999px; background:#eef1f4; }
    .pill strong{ color:#000; }

    /* Tablero */
    .board-wrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:18px;
    }
    @media(min-width:960px){
      .board-wrap{ grid-template-columns: 600px 1fr; align-items:start; }
    }

    .board{
      width: 100%;
      max-width: 600px;
      aspect-ratio: 1/1;
      display:grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      border:3px solid var(--grid);
      border-radius: 14px;
      overflow:hidden;
      background:#fff;
      position:relative;
    }

    /* Alternancia de fondo por subcuadros 3x3 (patrón de damas sobre la grilla) */
    .boxA{ background: var(--boxA); }
    .boxB{ background: var(--boxB); }

    .cell{
      border: 1px solid #bfbfbf40;
      position:relative;
    }
    /* Líneas gruesas 3x3 */
    .cell[data-r="2"], .cell[data-r="5"]{ border-bottom: 3px solid var(--grid); }
    .cell[data-c="2"], .cell[data-c="5"]{ border-right: 3px solid var(--grid); }

    .cell input{
      width:100%; height:100%;
      border:0; outline:none;
      font-size: clamp(18px, 2.8vw, 28px);
      text-align:center;
      background: transparent;
      color:#111;
      caret-color: var(--accent);
    }
    .prefilled input{ font-weight:800; color:#000; }
    .invalid input{ background: rgba(209,36,47,.12); }
    .valid input{ background: rgba(45,164,78,.12); }

    .panel{
      display:grid; gap:12px;
    }

    .share{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      padding:10px; border:1px dashed #c9d1d9; border-radius:12px; background:#fafbfc;
    }

    .rank{
      margin-top:8px; border-collapse: collapse; width:100%; font-size:14px;
      background:#fff; border-radius:12px; overflow:hidden; border:1px solid #e5e7eb;
    }
    .rank th, .rank td{ padding:10px 12px; border-bottom:1px solid #f1f5f9; text-align:left; }
    .rank thead{ background:#f8fafc; }
    .muted{ color:#666; }

    .help{ font-size:12px; color:#666; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Sudoku</h1>
    <div class="sub">Dificultad, temporizador, ranking local por tiempo, corrección, resolución e ID compartible.</div>

    <div class="toolbar">
      <div class="controls">
        <label for="diff">Dificultad:</label>
        <select id="diff" aria-label="Seleccionar dificultad">
          <option value="facil">Fácil</option>
          <option value="media" selected>Media</option>
          <option value="dificil">Difícil</option>
        </select>

        <button class="btn primary" id="newBtn">Nuevo juego</button>
        <button class="btn" id="checkBtn">Corregir</button>
        <button class="btn success" id="solveBtn">Resolver</button>
      </div>

      <div class="status">
        <div class="pill">ID: <strong id="gameId">—</strong></div>
        <div class="pill">Dificultad: <strong id="badgeDiff">—</strong></div>
        <div class="pill">Tiempo: <strong id="timer">00:00</strong></div>
      </div>
    </div>

    <div class="board-wrap">
      <div id="board" class="board" aria-label="Tablero de Sudoku"></div>

      <div class="panel">
        <div class="share">
          <label for="loadId"><strong>Compartir / cargar ID</strong></label>
          <input id="loadId" type="text" placeholder="Pegar ID o URL con ?seed=123456&d=media" />
          <button class="btn" id="loadBtn">Cargar</button>
          <button class="btn" id="copyBtn">Copiar enlace</button>
        </div>

        <table class="rank" aria-label="Ranking">
          <thead>
            <tr><th colspan="4">Ranking local por dificultad (mejores tiempos)</th></tr>
            <tr><th>#</th><th>Dificultad</th><th>Tiempo</th><th>ID</th></tr>
          </thead>
          <tbody id="rankBody">
            <tr><td colspan="4" class="muted">Sin registros.</td></tr>
          </tbody>
        </table>

        <div class="help">
          Nota: El ranking se guarda en este navegador (localStorage). El ID identifica el rompecabezas; compártalo con
          <code>?seed=SEED&d=DIFICULTAD</code> para reproducir la misma partida en otro dispositivo.
        </div>
      </div>
    </div>
  </div>

  <script>
    // ----------------------- Utilidades -----------------------
    const $ = s => document.querySelector(s);
    const $$ = s => [...document.querySelectorAll(s)];
    const byId = id => document.getElementById(id);

    function pad(n){ return String(n).padStart(2,'0'); }
    function fmtTime(sec){ const m = Math.floor(sec/60), s = sec%60; return `${pad(m)}:${pad(s)}`; }

    // PRNG determinista (Mulberry32) para reproducibilidad por seed
    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }
    function randInt(prng, min, max){ // [min, max)
      return Math.floor(prng() * (max - min)) + min;
    }
    function shuffle(arr, prng){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(prng()* (i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    }

    // ----------------------- Generación de solución base -----------------------
    // Patrón clásico: base 3x3 con permutaciones de filas/columnas y permutación de dígitos
    function pattern(r,c){ return ( (r*3 + Math.floor(r/3) + c) % 9 ); }

    function generateSolved(seed){
      const prng = mulberry32(seed>>>0);
      // Permutación de dígitos 1..9
      const digits = shuffle([1,2,3,4,5,6,7,8,9], prng);

      // Permutaciones de filas/columnas por bandas/pilas
      const rows = [].concat(
        shuffle([0,1,2], prng).map(r=>r),
        shuffle([3,4,5], prng).map(r=>r),
        shuffle([6,7,8], prng).map(r=>r)
      );
      const cols = [].concat(
        shuffle([0,1,2], prng).map(c=>c),
        shuffle([3,4,5], prng).map(c=>c),
        shuffle([6,7,8], prng).map(c=>c)
      );

      const grid = Array.from({length:9}, ()=> Array(9).fill(0));
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          grid[r][c] = digits[ pattern(rows[r], cols[c]) ];
        }
      }
      return grid;
    }

    // ----------------------- Crear puzzle desde solución -----------------------
    const emptiesByDiff = { facil: 36, media: 46, dificil: 53 }; // celdas vacías aproximadas

    function gridClone(g){ return g.map(row=>row.slice()); }

    function makePuzzleFromSolution(solution, diff, seed){
      const prng = mulberry32((seed ^ 0x9e3779b9)>>>0);
      const puzzle = gridClone(solution);
      const emptiesTarget = emptiesByDiff[diff] ?? 46;

      // Eliminación simétrica para estética
      const positions = [];
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          positions.push([r,c]);
        }
      }
      shuffle(positions, prng);

      let removed = 0;
      for(const [r,c] of positions){
        if (removed >= emptiesTarget) break;
        if (puzzle[r][c] === 0) continue;

        const r2 = 8 - r, c2 = 8 - c;
        const keepOriginal = puzzle[r][c];
        const keepMirror = puzzle[r2][c2];

        puzzle[r][c] = 0;
        if (!(r===r2 && c===c2)) puzzle[r2][c2] = 0;

        removed += (r===r2 && c===c2) ? 1 : 2;
      }
      return puzzle;
    }

    // ----------------------- Solver (para validar/corregir y resolver) -----------------------
    function isValid(grid, r, c, val){
      for(let k=0;k<9;k++){
        if(grid[r][k]===val || grid[k][c]===val) return false;
      }
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for(let i=0;i<3;i++){
        for(let j=0;j<3;j++){
          if(grid[br+i][bc+j]===val) return false;
        }
      }
      return true;
    }

    function solveGrid(grid){
      // Backtracking clásico
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          if(grid[r][c]===0){
            for(let v=1;v<=9;v++){
              if(isValid(grid, r, c, v)){
                grid[r][c]=v;
                if(solveGrid(grid)) return true;
                grid[r][c]=0;
              }
            }
            return false;
          }
        }
      }
      return true;
    }

    // ----------------------- Estado de juego -----------------------
    let current = { seed: 0, diff: 'media', solution: null, puzzle: null, startTs: 0, timerId: null, elapsed:0, finished:false };

    function getRandomSeed(){
      if (window.crypto?.getRandomValues){
        const arr = new Uint32Array(1); crypto.getRandomValues(arr); return arr[0]>>>0;
      }
      return Math.floor(Math.random()*2**32)>>>0;
    }

    function buildBoard(puzzle, solution){
      const board = byId('board');
      board.innerHTML = '';
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          const cell = document.createElement('div');
          cell.className = 'cell ' + (((Math.floor(r/3)+Math.floor(c/3))%2===0)?'boxA':'boxB');
          cell.dataset.r = r; cell.dataset.c = c;

          const input = document.createElement('input');
          input.inputMode = "numeric";
          input.pattern = "[1-9]";
          input.maxLength = 1;
          input.setAttribute('aria-label', `Fila ${r+1}, Columna ${c+1}`);

          if(puzzle[r][c]!==0){
            input.value = puzzle[r][c];
            input.disabled = true;
            cell.classList.add('prefilled');
          } else {
            input.value = '';
            input.addEventListener('input', (e)=>{
              const v = e.target.value.replace(/[^1-9]/g,'');
              e.target.value = v.slice(0,1);
              clearInvalid(cell);
              autoAdvance(r,c);
              checkSolved();
            });
            input.addEventListener('keydown', (e)=>{
              if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Backspace'].includes(e.key)){
                navigate(e.key, r, c, e);
              }
            });
          }
          cell.appendChild(input);
          board.appendChild(cell);
        }
      }
    }

    function clearInvalid(cell){
      cell.classList.remove('invalid','valid');
    }

    function autoAdvance(r,c){
      // Mover al siguiente hueco
      let idx = r*9 + c;
      for(let k=1;k<81;k++){
        const n = (idx + k) % 81;
        const nr = Math.floor(n/9), nc = n%9;
        const target = cellAt(nr,nc).querySelector('input');
        if (target && !target.disabled){
          target.focus(); break;
        }
      }
    }

    function cellAt(r,c){
      return byId('board').children[r*9 + c];
    }

    function readUserGrid(){
      const g = Array.from({length:9}, ()=>Array(9).fill(0));
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          const inp = cellAt(r,c).querySelector('input');
          g[r][c] = inp && !inp.disabled && inp.value ? Number(inp.value) : (inp?.disabled ? Number(inp.value) : 0);
        }
      }
      return g;
    }

    function checkSolved(){
      if (!current.solution || current.finished) return;
      const g = readUserGrid();
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          if (g[r][c] !== current.solution[r][c]) return;
        }
      }
      onUserSolved();
    }

    function onUserSolved(){
      current.finished = true;
      stopTimer();
      markAll('valid');
      saveRanking(current.diff, current.seed, current.elapsed);
      renderRanking();
    }

    function markAll(cls){
      for(const cell of $$('#board .cell')){ cell.classList.remove('invalid','valid'); cell.classList.add(cls); }
    }

    // ----------------------- Temporizador -----------------------
    function startTimer(){
      stopTimer();
      current.startTs = Date.now();
      current.timerId = setInterval(()=>{
        current.elapsed = Math.floor((Date.now()-current.startTs)/1000);
        byId('timer').textContent = fmtTime(current.elapsed);
      }, 250);
    }
    function stopTimer(){
      if (current.timerId){ clearInterval(current.timerId); current.timerId = null; }
    }
    function resetTimer(){
      stopTimer(); current.elapsed = 0; byId('timer').textContent = '00:00';
    }

    // ----------------------- Ranking (localStorage) -----------------------
    const RANK_KEY = 'sudoku_ranking_v1';

    function loadRanking(){
      try{ return JSON.parse(localStorage.getItem(RANK_KEY) || '[]'); }
      catch{ return []; }
    }
    function saveRanking(diff, seed, seconds){
      const list = loadRanking();
      list.push({ diff, seed, seconds, ts: Date.now() });
      // Mantener top 10 por dificultad
      const filtered = list
        .sort((a,b)=> a.seconds - b.seconds)
        .reduce((acc, cur)=>{
          acc[cur.diff] = acc[cur.diff] || [];
          if (acc[cur.diff].length < 10) acc[cur.diff].push(cur);
          return acc;
        }, {});
      const flat = Object.values(filtered).flat();
      localStorage.setItem(RANK_KEY, JSON.stringify(flat));
    }
    function renderRanking(){
      const body = byId('rankBody');
      const list = loadRanking().sort((a,b)=> a.seconds - b.seconds);
      if(!list.length){
        body.innerHTML = `<tr><td colspan="4" class="muted">Sin registros.</td></tr>`;
        return;
      }
      body.innerHTML = '';
      list.forEach((row, i)=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${row.diff}</td><td>${fmtTime(row.seconds)}</td><td>${row.seed}</td>`;
        body.appendChild(tr);
      });
    }

    // ----------------------- Acciones de UI -----------------------
    function newGame(seed, diff){
      // Generar solución y puzzle reproducibles por seed
      const solution = generateSolved(seed);
      const puzzle = makePuzzleFromSolution(solution, diff, seed);

      current = { seed, diff, solution, puzzle, startTs:0, timerId:null, elapsed:0, finished:false };

      const url = new URL(location.href);
      url.searchParams.set('seed', String(seed));
      url.searchParams.set('d', diff);
      history.replaceState(null, '', url.toString());

      byId('gameId').textContent = seed;
      byId('badgeDiff').textContent = diff;
      buildBoard(puzzle, solution);
      resetTimer();
      startTimer();
    }

    function correctBoard(){
      if (!current.solution) return;
      let errors = 0;
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          const cell = cellAt(r,c);
          if (cell.classList.contains('prefilled')) { cell.classList.remove('invalid','valid'); continue; }
          const inp = cell.querySelector('input');
          const v = inp.value ? Number(inp.value) : 0;
          cell.classList.remove('invalid','valid');
          if (v===0) continue;
          if (v !== current.solution[r][c]) { cell.classList.add('invalid'); errors++; }
        }
      }
      return errors;
    }

    function solveBoard(){
      if (!current.solution) return;
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          const cell = cellAt(r,c);
          const inp = cell.querySelector('input');
          inp.value = current.solution[r][c];
        }
      }
      current.finished = true;
      stopTimer();
      markAll('valid');
      // No se registra en ranking cuando se usa "Resolver"
    }

    function navigate(key, r, c, e){
      const map = {
        ArrowUp: [-1,0], ArrowDown:[1,0], ArrowLeft:[0,-1], ArrowRight:[0,1]
      };
      if (key==='Backspace'){
        const inp = e.target;
        if (!inp.value){
          // retroceso a la celda anterior
          let idx = r*9 + c;
          for(let k=1;k<81;k++){
            const n = (idx - k + 81) % 81;
            const nr = Math.floor(n/9), nc = n%9;
            const target = cellAt(nr,nc).querySelector('input');
            if (target && !target.disabled){
              target.focus(); break;
            }
          }
        }
        return;
      }
      const d = map[key]; if (!d) return;
      e.preventDefault();
      let nr = r + d[0], nc = c + d[1];
      while(nr>=0 && nr<9 && nc>=0 && nc<9){
        const target = cellAt(nr,nc).querySelector('input');
        if (target && !target.disabled){ target.focus(); break; }
        nr += d[0]; nc += d[1];
      }
    }

    // ----------------------- Compartir / Cargar -----------------------
    function currentUrl(){
      const url = new URL(location.href);
      url.searchParams.set('seed', String(current.seed));
      url.searchParams.set('d', current.diff);
      return url.toString();
    }

    async function copyLink(){
      const link = currentUrl();
      try{
        await navigator.clipboard.writeText(link);
        alert('Enlace copiado al portapapeles.');
      }catch{
        // Fallback: seleccionar en input
        byId('loadId').value = link;
        byId('loadId').select();
        alert('No se pudo copiar automáticamente. El enlace fue colocado en el campo para que lo copie manualmente.');
      }
    }

    function loadFromInput(){
      const raw = byId('loadId').value.trim();
      if (!raw) return;
      try{
        let seed, d;
        if (/^https?:\/\//i.test(raw)){
          const u = new URL(raw);
          seed = parseInt(u.searchParams.get('seed')||'');
          d = (u.searchParams.get('d')||'').toLowerCase();
        }else{
          // permitir pegar solo el número de seed y opcionalmente la dificultad
          const parts = raw.split(/[,\s]+/).filter(Boolean);
          seed = parseInt(parts[0]);
          d = (parts[1]||byId('diff').value).toLowerCase();
        }
        if (!Number.isFinite(seed)) throw new Error();
        if (!['facil','media','dificil'].includes(d)) d = 'media';
        byId('diff').value = d;
        newGame(seed, d);
      }catch{
        alert('Formato no válido. Use un enlace con ?seed=...&d=... o pegue el número de ID.');
      }
    }

    // ----------------------- Inicio -----------------------
    function boot(){
      // Controles
      byId('newBtn').addEventListener('click', ()=>{
        const d = byId('diff').value;
        newGame(getRandomSeed(), d);
      });
      byId('checkBtn').addEventListener('click', ()=>{ const e = correctBoard(); if (e===0) checkSolved(); });
      byId('solveBtn').addEventListener('click', solveBoard);
      byId('copyBtn').addEventListener('click', copyLink);
      byId('loadBtn').addEventListener('click', loadFromInput);

      // Desde URL
      const u = new URL(location.href);
      const seedParam = parseInt(u.searchParams.get('seed')||'');
      const diffParam = (u.searchParams.get('d')||'').toLowerCase();
      const diff = ['facil','media','dificil'].includes(diffParam) ? diffParam : 'media';
      byId('diff').value = diff;

      const seed = Number.isFinite(seedParam) ? seedParam : getRandomSeed();
      newGame(seed, diff);

      renderRanking();
    }

    window.addEventListener('DOMContentLoaded', boot);
  </script>
</body>
</html>